大纲
- [数组](#数组)

# [数组](#数组)



交互式练习的网站
https://github.com/donnemartin/interactive-coding-challenges?tab=readme-ov-file


- 数据结构篇  
    
    - 数组  
        
        - [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)，简单  

        - [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)，中等  
        
        - [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix)，中等  
    
        - [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image)，中等  
            
    
    - 链表  
        
        - [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list)，简单  
            
        
        - [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group)，困难  
            
        
        - [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle)，简单  
            
        
        - [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists)，简单  
            
        
        - [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists)，简单  
            
        
        - [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)，中等  
            
        
        - [23. 合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists)，困难  
            
        
        - [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)，中等  
            
        
        - [143. 重排链表](https://leetcode-cn.com/problems/reorder-list)，中等  
            
        
        - [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)，简单  
            
        
        - [19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list)，中等  
            
        
        - [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii)，中等  
            
        
        - [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers)，中等  
            
        
        - [148. 排序链表](https://leetcode-cn.com/problems/sort-list)，中等  
            
        
        - [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)，简单  
            
        
        - [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)，简单  
            
        
        - [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)，中等  
            
        
        - [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)，中等  
            
    
    - 二叉树  
        
        - 遍历  
            
            - 前序遍历  
                - [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal)，简单  
                    
            
            - 中序遍历  
                - [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal)，简单  
                    
            
            - 后序遍历  
                
            
            - 层序遍历  
                
                - [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal)，中等  
                    
                
                - [103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)，中等  
                    
            
            - 视图  
                - [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view)，中等  
                    
        
        - 二叉搜索树  
            
            - [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree)，中等  
                
            
            - [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)，简单  
                
            
            - [426. 将二叉搜索树转化为排序的双向链表](https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/)，中等  
                
        
        - 求深度  
            
            - [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree)，简单  
                
            
            - [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)，简单  
                
        
        - 求直径  
            - [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)，简单  
                
        
        - 对称  
            - [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)，简单  
                
        
        - 翻转  
            - [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)，简单  
                
        
        - 最近公共祖先  
            - [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree)，中等  
                
        
        - 路径  
            
            - [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)，简单  
                
            
            - [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)，困难  
                
        
        - 重建二叉树  
            - [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)，中等  
                
    
    - 栈与队列  
        
        - [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses)，简单  
            
        
        - [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)，困难  
            
        
        - [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks)，简单  
            
        
        - [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)，简单  
            
        
        - [227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/)，中等  
            
    
    - 哈希表 HashMap  
        
        - [146. LRU缓存机制](https://leetcode-cn.com/problems/lru-cache)，中等  
            
        
        - [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)，简单  
            
        
        - [15. 三数之和](https://leetcode-cn.com/problems/3sum/)，中等  
            
        
        - [41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)，困难  
            
        
        - [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)，简单  
            
        
        - [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)，中等  
            
    
    - 字符串  
        
        - [415. 字符串相加](https://leetcode-cn.com/problems/add-strings)，简单  
            
        
        - [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi)，中等  
            
        
        - [151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)，中等  
            
        
        - [43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)，中等  
            
        
        - [468. 验证IP地址](https://leetcode-cn.com/problems/validate-ip-address/)，中等  
            
        
        - [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)，简单  
            
        
        - [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)，中等  
            
    
    - 堆  
        - [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)，中等  
            
- 算法篇  
    
    - 二分查找  
        
        - [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)，容易  
            
        
        - [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)，中等  
            
        
        - [69. Sqrt(x)](https://leetcode-cn.com/problems/sqrtx/)，简单  
            
        
        - [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)，困难  
            
        
        - [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)，中等  
            
        
        - [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)，中等  
            
        
        - [162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)，中等  
            
    
    - 排序  
        
        - [912. 快速排序](https://leetcode-cn.com/problems/sort-an-array/)，中等  
            
        
        - [912. 归并排序](https://leetcode-cn.com/problems/sort-an-array/)，中等  
            
        
        - [912. 堆排序](https://leetcode-cn.com/problems/sort-an-array/)，中等  
            
        
        - [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals)，中等  
            
        
        - [179. 最大数](https://leetcode-cn.com/problems/largest-number/)，中等  
            
    
    - 深度优先搜索 DFS  
        
        - [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)，中等  
            
        
        - [129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)，中等  
            
    
    - 广度优先搜索 BFS  
        
        - [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)，中等  
            
        
        - [958. 二叉树的完全性检验](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/)，中等  
            
    
    - 位运算  
        - [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)，简单  
            
- 算法思维  
    
    - 双指针  
        
        - [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)，中等  
            
        
        - [165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)，中等  
            
    
    - 滑动窗口  
        
        - [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters)，中等  
            
        
        - [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring)，困难  
            
        
        - [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum)，困难  
            
    
    - 回溯法  
        
        - [46. 全排列](https://leetcode-cn.com/problems/permutations/)，中等  
            
        
        - [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)，中等  
            
        
        - [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)，中等  
            
        
        - [78. 子集](https://leetcode-cn.com/problems/subsets/)，中等  
            
        
        - [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)，中等  
            
        
        - [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)，中等  
            
    
    - 动态规划  
        
        - [53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)，简单  
            
        
        - [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)，简单  
            
        
        - [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)，中等  
            
        
        - [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring)，中等  
            
        
        - [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)，中等  
            
        
        - [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs)，简单  
            
        
        - [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance)，困难  
            
        
        - [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence)，中等  
            
        
        - [718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)，中等  
            
        
        - [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)，中等  
            
        
        - [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)，困难  
            
        
        - [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)，中等  
            
        
        - [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)，中等  
            
        
        - [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)，中等  
            
        
        - [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)，中等  
            
    
    - 数学  
        - [470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)，中等

来源是 https://mubu.com/doc/7jiBYKCKqet




## [[#数组]]


##  动态规划

### 最长公共子序列的

最长公共子序列问题是一个经典的动态规划（Dynamic Programming）问题，其目标是找到两个序列中的最长公共子序列的长度。

假设我们有两个序列，分别称为序列 X 和序列 Y。我们的目标是找到 X 和 Y 的最长公共子序列的长度。

**定义** ：
- 序列 X: x1, x2, ..., xm
- 序列 Y: y1, y2, ..., yn

一个序列 Z = z1, z2, ..., zk 被称为序列 X 和序列 Y 的公共子序列，如果 Z 同时是 X 和 Y 的子序列。换句话说，Z 可以通过从 X 和 Y 中同时删除一些元素而获得。

**动态规划解法** ：
我们可以使用动态规划来解决最长公共子序列问题。定义一个二维数组 `dp`，其中 `dp[i][j]` 表示序列 `X` 的前 `i` 个元素和序列 `Y` 的前 `j` 个元素的最长公共子序列的长度。

接下来，我们定义状态转移方程： 
- 如果 `X[i-1] == Y[j-1]`，即序列 `X` 的第 `i` 个元素等于序列 `Y` 的第 `j` 个元素，则 `dp[i][j] = dp[i-1][j-1] + 1`，表示当前元素可以成为最长公共子序列的一部分。 
- 如果 `X[i-1] != Y[j-1]`，即序列 `X` 的第 `i` 个元素不等于序列 `Y` 的第 `j` 个元素，则 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`，表示当前位置的最长公共子序列长度等于不包括当前元素时两个序列的最长公共子序列长度的较大值。

**初始化** ： 
- 当 `i = 0` 或 `j = 0` 时，`dp[i][j]` 初始化为 `0`，因为任何一个序列和空序列的最长公共子序列长度都是 `0`。

**最终结果** ：
最终的最长公共子序列的长度存储在 `dp[m][n]` 中，其中 `m` 是序列 `X` 的长度，`n` 是序列 `Y` 的长度。

**时间复杂度** ：
动态规划解法的时间复杂度为 `O(mn)`，其中 `m` 是序列 `X` 的长度，`n` 是序列 `Y` 的长度。

希望这个解释对你有帮助！如果需要更多详细的解释或者例子，请随时告诉我。

**Python 实现：**

```python
def longest_common_subsequence(X, Y):
    m = len(X)
    n = len(Y)
    
    # 创建dp数组，多一行一列用于存储边界条件
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # 填充dp数组
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if X[i - 1] == Y[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    
    # 返回最长公共子序列的长度
    return dp[m][n]

# 测试代码
def test_longest_common_subsequence():
    # 测试用例1
    X1 = "ABCBDAB"
    Y1 = "BDCAB"
    assert longest_common_subsequence(X1, Y1) == 4  # "BCAB" 是最长公共子序列
    
    # 测试用例2
    X2 = "AGGTAB"
    Y2 = "GXTXAYB"
    assert longest_common_subsequence(X2, Y2) == 4  # "GTAB" 是最长公共子序列
    
    # 测试用例3
    X3 = "abcdef"
    Y3 = "ghijkl"
    assert longest_common_subsequence(X3, Y3) == 0  # 没有公共子序列

    print("所有测试用例通过!")

# 执行单元测试
test_longest_common_subsequence()
```

如果以上测试用例都通过（输出 "所有测试用例通过!"），则说明 `longest_common_subsequence` 函数实现正确。


1. **两数之和（Two Sum）** 
- 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数的索引。
- 要求时间复杂度为 O(n)。 
2. **反转链表（Reverse Linked List）** 
- 反转一个单链表。 
3. **最长连续递增序列（Longest Continuous Increasing Subsequence）** 
- 找出给定整数数组中最长的连续递增子序列的长度。 
4. **二叉树的遍历（Binary Tree Traversal）** 
- 实现二叉树的前序、中序和后序遍历，可以使用递归或迭代方式实现。 
5. **回文数（Palindrome Number）** 
- 判断一个整数是否是回文数，例如 121 是回文数，-121 不是回文数。 
6. **合并两个有序链表（Merge Two Sorted Lists）** 
- 合并两个有序链表为一个新的有序链表。 
7. **字符串中的第一个唯一字符（First Unique Character in a String）** 
- 找出字符串中第一个不重复的字符并返回其索引。 
8. **最大子序和（Maximum Subarray）**
- 找到一个数组中具有最大和的连续子数组。 
9. **验证二叉搜索树（Validate Binary Search Tree）** 
- 判断给定的二叉树是否是一个有效的二叉搜索树。 
10. **LRU缓存设计（LRU Cache Design）** 
- 设计实现一个最近最少使用（LRU）缓存机制，支持 get 和 put 操作。

这些算法题目覆盖了数组、链表、树、字符串、动态规划等常见的数据结构和算法问题。在面试中，掌握这些基础算法题目，并能够清晰地解释思路和实现过程，通常能展现出良好的编程能力和算法理解能力。记得在准备面试时，除了编写代码，还要注重理解算法的原理和分析时间复杂度。

Person: 
- 详细阐述翻转链表的解法，给出代码

ChatGPT: 
- 翻转链表是一个经典的链表操作题，主要任务是将一个单链表进行反转，即将链表的每个节点的指向方向从原来的单向改为相反的方向。下面我将详细阐述翻转链表的解法，并给出相应的 Python 代码实现。
### 解法详解：
#### 迭代法：

迭代法是一种常见且直观的解法，通过遍历链表，逐个将节点的指针方向反转。 
1. **初始化两个指针** ： 
- `prev`：用于记录当前节点的前一个节点，初始为 `None`。 
- `current`：当前遍历到的节点，初始为链表的头节点 `head`。 
2. **遍历链表** ： 
- 在遍历过程中，依次处理每个节点 `current`： 
- 将 `current` 的下一个节点暂存为 `next_node`。 
- 将 `current` 的 `next` 指针指向 `prev`，完成当前节点的反转。 
- 更新 `prev` 为当前节点 `current`。 
- 更新 `current` 为下一个待处理的节点 `next_node`。 
3. **反转完成** ： 
- 当遍历完成后，`prev` 指向的节点即为反转后链表的头节点。
#### 代码实现（迭代法）：

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverse_linked_list(head):
    if not head or not head.next:
        return head
    
    prev = None
    current = head
    
    while current:
        next_node = current.next  # 暂存当前节点的下一个节点
        current.next = prev  # 反转当前节点的指针方向
        prev = current  # 更新prev指针
        current = next_node  # 更新current指针为下一个节点
    
    return prev  # prev现在指向新的头节点

# 辅助函数：将链表转换为列表（方便测试）
def list_to_linked_list(lst):
    if not lst:
        return None
    head = ListNode(lst[0])
    current = head
    for val in lst[1:]:
        current.next = ListNode(val)
        current = current.next
    return head

# 辅助函数：将链表转换为列表（方便测试）
def linked_list_to_list(head):
    lst = []
    current = head
    while current:
        lst.append(current.val)
        current = current.next
    return lst

# 测试代码
def test_reverse_linked_list():
    # 创建测试链表: 1 -> 2 -> 3 -> 4 -> 5
    head = list_to_linked_list([1, 2, 3, 4, 5])
    
    # 翻转链表
    new_head = reverse_linked_list(head)
    
    # 验证翻转后的链表内容
    assert linked_list_to_list(new_head) == [5, 4, 3, 2, 1]

    # 创建测试链表: 1 -> 2 -> 3
    head2 = list_to_linked_list([1, 2, 3])
    
    # 翻转链表
    new_head2 = reverse_linked_list(head2)
    
    # 验证翻转后的链表内容
    assert linked_list_to_list(new_head2) == [3, 2, 1]

    print("所有测试用例通过!")

# 执行单元测试
test_reverse_linked_list()
```


### 代码解释： 
- `ListNode` 类定义了链表的节点结构，每个节点包含一个值 `val` 和指向下一个节点的指针 `next`。 
- `reverse_linked_list` 函数接收链表的头节点 `head`，通过迭代遍历链表，逐个反转节点的指针方向，并返回反转后的新头节点。 
- `list_to_linked_list` 和 `linked_list_to_list` 是辅助函数，用于将列表和链表之间进行转换，方便测试。 
- `test_reverse_linked_list` 函数用于执行测试，创建测试链表并调用 `reverse_linked_list` 进行翻转，最后验证翻转后的结果是否符合预期。

希望这个详细的解释和代码实现能够帮助你理解翻转链表的解法和实现过程。如果有任何疑问或需要进一步解释，请随时告诉我！
